<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>APB</title>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client@2/dist/livekit-client.umd.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --vh: 1vh;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000000;
            min-height: 100vh;
            min-height: calc(var(--vh, 1vh) * 100);
            color: #ffffff;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            min-height: calc(var(--vh, 1vh) * 100);
            display: flex;
            flex-direction: column;
        }
        
        .main-content-wrapper {
            display: flex;
            gap: 20px;
            flex: 1;
        }
        
        /* Illustration Sidebar (right side) */
        .illustration-sidebar {
            width: 270px;
            min-width: 270px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 200, 100, 0.15);
            border-radius: 20px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            height: fit-content;
            max-height: calc(100vh - 200px);
            margin-top: 30px;
        }
        
        .illustration-sidebar-header {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 200, 100, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .illustration-sidebar-header span {
            color: rgb(255, 200, 100);
        }
        
        .illustration-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            max-height: 600px;
            padding-right: 5px;
        }
        
        .illustration-list::-webkit-scrollbar {
            width: 4px;
        }
        
        .illustration-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .illustration-list::-webkit-scrollbar-thumb {
            background: rgba(255, 200, 100, 0.3);
            border-radius: 2px;
        }
        
        .sidebar-illustration-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 200, 100, 0.2);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .sidebar-illustration-item iframe {
            width: 100%;
            height: 135px;
            min-height: 135px;
            border: none;
            display: block;
        }
        
        .sidebar-illustration-info {
            padding: 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            border-top: 1px solid rgba(255, 200, 100, 0.1);
        }
        
        .sidebar-illustration-info .illustration-title {
            color: rgb(255, 200, 100);
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .sidebar-illustration-info .illustration-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            line-height: 1.4;
            margin-bottom: 6px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .sidebar-illustration-info .illustration-tone {
            display: inline-block;
            background: rgba(255, 200, 100, 0.15);
            color: rgb(255, 200, 100);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .sidebar-illustration-info .illustration-timestamp {
            color: rgb(255, 200, 100);
            font-size: 10px;
            margin-left: 8px;
        }
        
        .illustration-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 13px;
        }
        
        .illustration-empty-state svg {
            width: 48px;
            height: 48px;
            fill: rgba(255, 200, 100, 0.2);
            margin-bottom: 12px;
        }
        
        .video-sidebar {
            width: 270px;
            min-width: 270px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            height: fit-content;
            max-height: calc(100vh - 200px);
            margin-top: 30px;
        }
        
        .video-sidebar-header {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .video-sidebar-header span {
            color: rgb(0, 255, 65);
        }
        
        .video-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            max-height: 600px;
            padding-right: 5px;
        }
        
        .video-list::-webkit-scrollbar {
            width: 4px;
        }
        
        .video-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .video-list::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 65, 0.3);
            border-radius: 2px;
        }
        
        .sidebar-video-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
            min-height: 180px;
        }
        
        .sidebar-video-item iframe {
            width: 100%;
            height: 135px;
            min-height: 135px;
            border: none;
            display: block;
        }
        
        .sidebar-video-info {
            padding: 8px 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .sidebar-video-info .video-title {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .sidebar-video-info .video-timestamp {
            color: rgb(0, 255, 65);
            font-size: 10px;
        }
        
        .video-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 13px;
        }
        
        .video-empty-state svg {
            width: 48px;
            height: 48px;
            fill: rgba(255, 255, 255, 0.2);
            margin-bottom: 12px;
        }
        
        .main-content {
            flex: 1;
        }

        .header {
            text-align: center;
            padding: 40px 0 30px;
        }

        .header h1 {
            font-size: 72px;
            font-weight: 700;
            letter-spacing: -3px;
            background: linear-gradient(135deg, #ffffff 0%, #a0a0a0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .voice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 50px 30px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 32px;
            margin-top: 30px;
            position: relative;
        }

        /* Chat Window */
        .chat-window {
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 0;
            margin-bottom: 32px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Text Input Container */
        .text-input-container {
            width: 100%;
            margin-bottom: 20px;
        }

        .text-input-wrapper {
            display: flex;
            gap: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            padding: 8px 8px 8px 24px;
            transition: all 0.3s ease;
        }

        .text-input-wrapper:focus-within {
            border-color: rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.08);
        }

        #textInput {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #ffffff;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            padding: 10px 0;
        }

        #textInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        #sendBtn {
            background: #000000;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #sendBtn:not(:disabled):hover,
        #sendBtn:not(:disabled):focus {
            background: rgb(0, 255, 65) !important;
            border-color: rgb(0, 255, 65) !important;
            color: #000000 !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.4);
            outline: none;
        }

        #sendBtn:active {
            transform: scale(0.98);
        }

        #sendBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Menu Links */
        .menu-links {
            position: fixed;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .menu-links a,
        .menu-links a:link,
        .menu-links a:visited {
            color: #ffffff;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .menu-links a:hover,
        .menu-links a:focus {
            color: rgb(0, 255, 65) !important;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .chat-window::-webkit-scrollbar {
            width: 0;
            display: none;
        }

        /* Message Bubbles */
        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 15px;
            line-height: 1.4;
            color: #ffffff;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            background: rgb(0, 255, 65);
            align-self: flex-end;
            border-bottom-right-radius: 6px;
            margin-left: auto;
            color: #000000;
        }

        .message.agent {
            background: #2d2d2d;
            align-self: flex-start;
            border-bottom-left-radius: 6px;
            margin-right: auto;
            max-width: 95%;
        }

        /* Sermon Links and References */
        .message .sermon-link {
            display: inline-block;
            color: #4CAF50;
            text-decoration: none;
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .message .sermon-link:hover {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .message .sermon-ref {
            display: block;
            color: #64B5F6;
            margin: 8px 0 4px 0;
            font-weight: 600;
            border-left: 3px solid #64B5F6;
            padding-left: 8px;
        }

        .message .scripture-ref {
            color: #FFD54F;
            font-weight: 500;
            background: rgba(255, 213, 79, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
        }
        
        /* Embedded Video Styles */
        .sermon-video-container {
            margin: 10px 0;
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.6);
            max-width: 280px;
            width: 280px;
        }
        
        .video-header {
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.2) 0%, rgba(0, 200, 50, 0.2) 100%);
            color: white;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
        }
        
        .external-link {
            color: rgb(0, 255, 65);
            text-decoration: none;
            font-size: 0.85em;
            padding: 4px 10px;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 20px;
            transition: all 0.3s;
        }
        
        .external-link:hover {
            background: rgba(0, 255, 65, 0.2);
            border-color: rgb(0, 255, 65);
        }
        
        .sermon-video-container iframe {
            display: block;
            border: none;
            width: 100%;
            height: 158px;
        }

        .message.system {
            background: transparent;
            align-self: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            padding: 8px;
            text-align: center;
        }

        /* Typing indicator */
        .typing {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: #2d2d2d;
            align-self: flex-start;
            border-radius: 18px;
            border-bottom-left-radius: 6px;
            max-width: 60px;
        }

        .typing span {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing span:nth-child(1) { animation-delay: -0.32s; }
        .typing span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0.8); }
            40% { transform: scale(1.2); }
        }

        /* Voice Button */
        #voiceBtn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #voiceBtn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        #voiceBtn.listening {
            background: linear-gradient(135deg, rgb(0, 255, 65) 0%, rgb(0, 200, 50) 100%);
            border-color: rgb(0, 255, 65);
            animation: pulse-green 1.5s infinite;
        }

        #voiceBtn.connecting {
            background: linear-gradient(135deg, rgb(0, 200, 50) 0%, rgb(0, 150, 40) 100%);
            border-color: rgb(0, 200, 50);
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 65, 0.5); }
            70% { box-shadow: 0 0 0 30px rgba(0, 255, 65, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 65, 0); }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5); }
            70% { box-shadow: 0 0 0 30px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        #voiceBtn svg {
            width: 56px;
            height: 56px;
            fill: white;
            transition: fill 0.3s ease;
        }
        
        #voiceBtn.listening svg,
        #voiceBtn.connecting svg {
            fill: black;
        }

        .voice-status {
            margin-top: 24px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            font-weight: 500;
        }

        .agent-status {
            margin-top: 16px;
            padding: 10px 24px;
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 50px;
            color: #22c55e;
            font-size: 14px;
            display: none;
        }

        .agent-status.active {
            display: block;
        }

        .agent-status.speaking {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        /* Audio Level Indicator */
        .audio-level-container {
            margin-top: 32px;
            margin-bottom: 32px;
            width: 100%;
            max-width: 400px;
        }

        .audio-level-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .audio-level-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .audio-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        /* Voice Response Toggle */
        .voice-response-toggle {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .toggle-response-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
        }

        .toggle-switch input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 22px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #22c55e;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(18px);
        }

        .toggle-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 8px;
        }

        .toggle-switch input:not(:checked) ~ .toggle-label {
            opacity: 0.7;
        }

        /* Chat window - no scrollbar on outer container */
        .chat-window {
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
        }
        
        /* Fixed header for toggle and instruction - stays at top */
        .chat-header-sticky {
            position: relative;
            z-index: 10;
            background: #000000;
            padding: 12px 15px;
            border-radius: 20px 20px 0 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .chat-header-sticky .instruction-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            flex: 1;
        }
        
        .chat-header-sticky .voice-response-toggle {
            position: static;
            flex-shrink: 0;
        }
        
        /* Scrollable messages area */
        .chat-messages-container {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 20px;
            min-height: 0;
        }
        
        .chat-messages-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        /* Clear Button */
        .clear-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .clear-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* Debug Panel */
        .debug-panel {
            margin-top: 32px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            color: #22c55e;
        }

        .debug-panel::-webkit-scrollbar {
            width: 6px;
        }

        .debug-panel::-webkit-scrollbar-thumb {
            background: rgba(34, 197, 94, 0.3);
            border-radius: 3px;
        }

        .log-entry {
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .log-entry.error { color: #ef4444; }
        .log-entry.success { color: #22c55e; }
        .log-entry.info { color: #a0a0a0; }
        .log-entry.warning { color: #f59e0b; }

        #agentAudio {
            display: none;
        }

        /* Responsive - Tablet */
        @media (max-width: 768px) {
            .app-container {
                padding: 15px;
            }
            
            .main-content-wrapper {
                flex-direction: column;
            }
            
            /* Order: main content first, then sermon clips, then illustration clips */
            .main-content {
                order: 1;
            }
            
            .video-sidebar {
                order: 2;
                width: 100%;
                min-width: unset;
                max-height: none;
                margin-top: 15px;
            }
            
            .illustration-sidebar {
                order: 3;
                width: 100%;
                min-width: unset;
                max-height: none;
                margin-top: 15px;
            }
            
            .video-list,
            .illustration-list {
                flex-direction: column;
                overflow-x: hidden;
                overflow-y: auto;
                max-height: unset;
                gap: 12px;
                padding-bottom: 10px;
            }
            
            .sidebar-video-item,
            .sidebar-illustration-item {
                min-width: unset;
                width: 100%;
                flex-shrink: 0;
                min-height: auto;
            }
            
            .sidebar-video-item iframe,
            .sidebar-illustration-item iframe {
                width: 100%;
                height: 180px;
                min-height: 180px;
            }
            
            .header {
                padding: 30px 0 20px;
            }
            
            .header h1 {
                font-size: 56px;
            }
            
            .voice-container {
                padding: 30px 20px;
                border-radius: 24px;
            }
            
            .chat-window {
                height: 350px;
            }
            
            .menu-links {
                position: fixed;
                top: 20px;
                right: 20px;
                gap: 15px;
            }
            
            .menu-links a {
                font-size: 13px;
            }
        }

        /* Responsive - Mobile */
        @media (max-width: 600px) {
            body {
                padding-top: 60px; /* Space for menu */
            }
            
            .app-container {
                padding: 10px;
                max-width: 100%;
            }
            
            .header {
                padding: 20px 0 15px;
            }
            
            .header h1 {
                font-size: 42px;
                letter-spacing: -2px;
            }
            
            .menu-links {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.95);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding: 12px 20px;
                justify-content: center;
                gap: 30px;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }
            
            .menu-links a {
                font-size: 12px;
                font-weight: 600;
            }
            
            .voice-container {
                padding: 25px 15px;
                border-radius: 20px;
                margin-top: 15px;
            }
            
            #voiceBtn {
                width: 100px;
                height: 100px;
            }
            
            #voiceBtn svg {
                width: 40px;
                height: 40px;
            }
            
            .voice-status {
                margin-top: 16px;
                font-size: 16px;
            }
            
            .agent-status {
                margin-top: 12px;
                padding: 8px 20px;
                font-size: 12px;
            }
            
            /* Audio Level */
            .audio-level-container {
                margin-top: 20px;
                margin-bottom: 20px;
                max-width: 100%;
            }
            
            .audio-level-label {
                font-size: 11px;
            }
            
            .audio-level-bar {
                height: 6px;
            }
            
            /* Text Input */
            .text-input-container {
                margin-bottom: 15px;
            }
            
            .text-input-wrapper {
                padding: 6px 6px 6px 20px;
                gap: 8px;
            }
            
            #textInput {
                font-size: 14px;
                padding: 8px 0;
            }
            
            #sendBtn {
                padding: 10px 20px;
                font-size: 12px;
            }
            
            /* Chat Window */
            .chat-window {
                height: 300px;
                padding: 0;
                border-radius: 16px;
                margin-bottom: 20px;
            }
            
            .chat-messages-container {
                padding: 12px 15px;
            }
            
            .message {
                font-size: 14px;
                padding: 10px 14px;
                max-width: 85%;
            }
            
            /* Debug Panel */
            .debug-panel {
                margin-top: 20px;
                padding: 15px;
                border-radius: 12px;
                max-height: 180px;
                font-size: 11px;
            }
            
            /* Clear Button */
            .clear-btn {
                position: static;
                margin-top: 15px;
                width: 100%;
                max-width: 200px;
            }
        }

        /* Responsive - Small Mobile */
        @media (max-width: 380px) {
            .header h1 {
                font-size: 36px;
            }
            
            .menu-links {
                gap: 20px;
            }
            
            .menu-links a {
                font-size: 11px;
            }
            
            #voiceBtn {
                width: 90px;
                height: 90px;
            }
            
            #voiceBtn svg {
                width: 36px;
                height: 36px;
            }
            
            .chat-window {
                height: 250px;
                padding: 0;
            }
            
            #textInput {
                font-size: 13px;
            }
            
            #sendBtn {
                padding: 10px 16px;
                font-size: 11px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            #voiceBtn:active {
                transform: scale(0.95);
            }
            
            #sendBtn:active {
                transform: scale(0.95);
            }
            
            .menu-links a:active {
                color: rgb(0, 255, 65) !important;
            }
        }

        /* Landscape mobile */
        @media (max-height: 600px) and (orientation: landscape) {
            .header {
                padding: 15px 0 10px;
            }
            
            .header h1 {
                font-size: 36px;
            }
            
            .voice-container {
                padding: 20px 15px;
            }
            
            #voiceBtn {
                width: 80px;
                height: 80px;
            }
            
            .chat-window {
                height: 200px;
                padding: 0;
            }
            
            .debug-panel {
                max-height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Menu Links (outside container for viewport positioning) -->
    <div class="menu-links">
        <a href="https://www.youtube.com/playlist?list=PLEgYquYMZK-Sd5TXQnYge2rC-_zS0zPnm" target="_blank">APB Podcast</a>
        <a href="https://www.youtube.com/playlist?list=PLEgYquYMZK-S5hMVvpeGJ4U-R627ZIQ94" target="_blank">Sermons</a>
    </div>

    <div class="app-container">
        <header class="header">
            <h1>APB</h1>
        </header>
        
        <div class="main-content-wrapper">
            <!-- Video Sidebar -->
            <div class="video-sidebar" id="videoSidebar">
                <div class="video-sidebar-header">
                    Sermon Clips <span id="videoCount">0</span>
                </div>
                <div class="video-list" id="videoList">
                    <div class="video-empty-state" id="videoEmptyState">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"/>
                        </svg>
                        <div>Ask a question to see related sermon clips</div>
                    </div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="main-content">
                <div class="voice-container">
            <!-- Voice Button with SVG -->
            <button id="voiceBtn" onclick="toggleVoice()">
                <!-- Microphone SVG -->
                <svg id="micIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                </svg>
                <!-- Stop SVG (hidden initially) -->
                <svg id="stopIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                    <rect x="6" y="6" width="12" height="12" rx="2"/>
                </svg>
            </button>
            <p class="voice-status" id="voiceStatus">Tap to connect</p>
            
            <div class="agent-status" id="agentStatus">ðŸ¤– Agent Connected</div>
            
            <!-- Audio Level Indicator -->
            <div class="audio-level-container">
                <div class="audio-level-label">
                    <span>Your Microphone</span>
                    <span id="audioLevelValue">0</span>
                </div>
                <div class="audio-level-bar">
                    <div class="audio-level-fill" id="audioLevelFill"></div>
                </div>
            </div>

            <!-- Chat Transcript Window -->
            <div class="chat-window" id="chatWindow">
                <!-- Sticky Header with Toggle and Instruction -->
                <div class="chat-header-sticky">
                    <span class="instruction-text">Type a message below or click the microphone for voice chat</span>
                    <div class="voice-response-toggle" id="voiceResponseToggle">
                        <div class="toggle-response-label">Response</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="voiceResponseCheckbox" checked>
                            <span class="toggle-slider"></span>
                            <span class="toggle-label">VOICE</span>
                        </label>
                    </div>
                </div>
                <!-- Scrollable messages container -->
                <div class="chat-messages-container" id="chatMessages"></div>
            </div>

            <!-- Text Input Container (below chat) -->
            <div class="text-input-container">
                <div class="text-input-wrapper">
                    <input 
                        type="text" 
                        id="textInput" 
                        placeholder="Type your message here..."
                        onkeypress="handleKeyPress(event)"
                        onfocus="handleTextInputFocus()"
                        autocomplete="off"
                        autocapitalize="sentences"
                        autocorrect="on"
                        spellcheck="true"
                    >
                    <button id="sendBtn" onclick="sendTextMessage()">Send</button>
                </div>
            </div>
            
            <!-- Debug Panel -->
            <div class="debug-panel" id="debugPanel"></div>
            
            <!-- Clear Button -->
            <button class="clear-btn" onclick="clearConversation()">Clear Chat</button>
        </div>
            </div><!-- /.main-content -->
            
            <!-- Illustration Sidebar (right side) -->
            <div class="illustration-sidebar" id="illustrationSidebar">
                <div class="illustration-sidebar-header">
                    Illustration Clips <span id="illustrationCount">0</span>
                </div>
                <div class="illustration-list" id="illustrationList">
                    <div class="illustration-empty-state" id="illustrationEmptyState">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                        </svg>
                        <div>Ask a question to see related illustration clips</div>
                    </div>
                </div>
            </div>
        </div><!-- /.main-content-wrapper -->
    </div>

    <audio id="agentAudio" autoplay></audio>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        // Use local server endpoint - change this if deploying
        const TOKEN_URL = '/token';  // Relative URL for local server
        const GROK_API_URL = '/api/chat';  // Use relative URL for local development
        
        // ============================================
        // STATE
        // ============================================
        let room = null;
        let isConnected = false;
        let audioMonitorInterval = null;
        let voiceResponseEnabled = true; // Track voice response preference
        let silentConnection = false; // Track if connection was from text input
        let typingTimeout = null;
        let autoDisconnectTimer = null; // Timer for auto-disconnect after response
        const AUTO_DISCONNECT_DELAY = 20000; // 20 seconds after agent finishes speaking
        let conversationHistory = [
            {
                role: 'system',
                content: `You are APB (Ask Pastor Bob), a warm and knowledgeable AI assistant for Calvary Chapel East Anaheim. Your job is to answer questions based on Pastor Bob Kopeny's sermon teachings.

=== YOUR #1 JOB ===
When sermon segments are appended to this message, you MUST read them and answer the user's question using that content. Say "Pastor Bob teaches..." and share what he says. The segments are his REAL words from REAL sermons. Always give a substantive answer.

=== BANNED PHRASES (NEVER SAY THESE) ===
- "I'd need to check"
- "I don't have a specific teaching"
- "I'd have to look into"
- "I'm not sure what Pastor Bob says about"
- Any variation of hedging, deflecting, or saying you lack information

=== WHAT TO DO INSTEAD ===
- Sermon segments provided? USE THEM. Read them, extract the answer, share it warmly.
- No sermon segments provided? Give a solid biblical answer. Do NOT say "Pastor Bob doesn't have a teaching on this" â€” just answer the question from Scripture.
- Personal questions about Pastor Bob? Use the VERIFIED FACTS below.

=== VERIFIED FACTS ABOUT PASTOR BOB ===
FAMILY:
- Wife: BECKY KOPENY (maiden name: Becky Olson)
- HOW THEY MET: Bob first met Becky briefly at church. Years later, while driving to Talbot Seminary, he stopped at the intersection of Chapman and Kramer in Placentia and "Becky Cal State Fullerton Placentia library" came into his mind. He found her at the library, they became friends, she got engaged to another man, that engagement ended, and three weeks after their first date Bob proposed. They married about 3.5 months later. Bob was about 25.
- THREE SONS: JESSE (oldest, 4 children), VALOR (middle, married to Stacy, son Luca), CHRISTIAN (youngest, married to Hayley, daughter Cora)

EDUCATION: Biola University (Bible major), Talbot Seminary (first class was Koine Greek)

CAREER BEFORE MINISTRY: Police Officer at La Habra PD, Detective at Placentia PD

TESTIMONY: Saved at age 13 at a Jr. High church camp. Friend FRED invited him. Two men - JEFF MAPLES and GENE SCHAEFFER - shared Christ with him for five minutes and he said yes.

=== RULES ===
1. NEVER invent stories, quotes, or teachings.
2. Spell his name correctly: KOPENY (not Copeny).
3. Be warm, helpful, and conversational.
4. Video clips appear in the sidebar automatically - don't list URLs in your response.`
            }
        ];

        // ============================================
        // CHAT FUNCTIONS
        // ============================================
        function addMessage(text, sender) {
            const chatMessages = document.getElementById('chatMessages');
            
            // Remove typing indicator if it exists
            const existingTyping = chatMessages.querySelector('.typing');
            if (existingTyping) existingTyping.remove();
            
            // Add message
            const msg = document.createElement('div');
            msg.className = `message ${sender}`;
            
            // Process text for YouTube links and sermon references
            if (sender === 'agent' || sender === 'assistant') {
                msg.innerHTML = formatMessageWithLinks(text);
            } else {
                msg.textContent = text;
            }
            
            chatMessages.appendChild(msg);
            
            // Auto scroll
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // ============================================
        // VIDEO SIDEBAR FUNCTIONS
        // ============================================
        let sidebarVideoCount = 0;
        const addedVideoKeys = new Set();
        
        const MAX_SIDEBAR_VIDEOS = 20;  // Allow accumulating videos across questions
        
        function addVideoToSidebar(title, url, timestamp, text) {
            const videoList = document.getElementById('videoList');
            const videoCount = document.getElementById('videoCount');
            const emptyState = document.getElementById('videoEmptyState');
            
            // Extract video ID and start time from URL
            const videoIdMatch = url.match(/v=([a-zA-Z0-9_-]+)/);
            if (!videoIdMatch) {
                console.log('Could not extract video ID from URL:', url);
                return;
            }
            const videoId = videoIdMatch[1];
            
            // Extract start time (seconds) for deduplication key
            let startSeconds = 0;
            const timeMatch = url.match(/[&?]t=(\d+)/);
            if (timeMatch) {
                startSeconds = parseInt(timeMatch[1]);
            }
            
            // Create unique key to prevent duplicates
            const videoKey = `${videoId}-${startSeconds}`;
            if (addedVideoKeys.has(videoKey)) {
                console.log('Duplicate video skipped:', videoKey);
                return;
            }
            
            // Limit to MAX_SIDEBAR_VIDEOS
            if (sidebarVideoCount >= MAX_SIDEBAR_VIDEOS) {
                console.log('Max videos reached (' + MAX_SIDEBAR_VIDEOS + '), not adding:', url);
                return;
            }
            
            // Mark as added (both local and global for cross-section dedup)
            addedVideoKeys.add(videoKey);
            globalVideoIds.add(videoId);
            
            // Hide empty state
            if (emptyState) {
                emptyState.style.display = 'none';
            }
            
            // Create embed URL with start parameter (correct format for iframe embed)
            const embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?start=${startSeconds}&rel=0&modestbranding=1&playsinline=1&enablejsapi=1`;
            
            // Create video item
            const videoItem = document.createElement('div');
            videoItem.className = 'sidebar-video-item';
            videoItem.innerHTML = `
                <iframe 
                    src="${embedUrl}"
                    title="${title || 'Sermon Clip'}"
                    frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                    allowfullscreen
                    playsinline
                    webkit-playsinline
                    loading="lazy">
                </iframe>
                <div class="sidebar-video-info">
                    <div class="video-title">${title || 'Sermon Clip'}</div>
                    <div class="video-timestamp">${timestamp || formatSecondsToTimestamp(startSeconds)}</div>
                </div>
            `;
            
            // Add to the beginning of the list
            videoList.insertBefore(videoItem, videoList.firstChild);
            
            // Update count
            sidebarVideoCount++;
            videoCount.textContent = sidebarVideoCount;
            
            console.log('Added video to sidebar:', videoId, 'at', startSeconds, 'seconds');
        }
        
        function clearVideoSidebar() {
            const videoList = document.getElementById('videoList');
            const videoCount = document.getElementById('videoCount');
            const emptyState = document.getElementById('videoEmptyState');
            
            // Remove all video items but keep empty state
            const items = videoList.querySelectorAll('.sidebar-video-item');
            items.forEach(item => item.remove());
            
            // Show empty state
            if (emptyState) {
                emptyState.style.display = 'block';
            }
            
            // Reset count and deduplication
            sidebarVideoCount = 0;
            addedVideoKeys.clear();
            globalVideoIds.clear();  // Also clear cross-section dedup
            videoCount.textContent = '0';
        }
        
        // ============================================
        // ILLUSTRATION SIDEBAR FUNCTIONS
        // ============================================
        let illustrationCount = 0;
        const addedIllustrationKeys = new Set();
        const MAX_SIDEBAR_ILLUSTRATIONS = 10;
        
        // Shared set for cross-section video deduplication (video_id only, not timestamp)
        const globalVideoIds = new Set();
        
        function addIllustrationToSidebar(title, text, tone, url, timestamp) {
            const illustrationList = document.getElementById('illustrationList');
            const illustrationCountEl = document.getElementById('illustrationCount');
            const emptyState = document.getElementById('illustrationEmptyState');
            
            // Create unique key from title + text start
            const key = `${title}-${(text || '').substring(0, 50)}`;
            if (addedIllustrationKeys.has(key)) {
                console.log('Duplicate illustration skipped:', title);
                return;
            }
            
            if (illustrationCount >= MAX_SIDEBAR_ILLUSTRATIONS) {
                console.log('Max illustrations reached');
                return;
            }
            
            addedIllustrationKeys.add(key);
            
            // Hide empty state
            if (emptyState) {
                emptyState.style.display = 'none';
            }
            
            // Create illustration item
            const item = document.createElement('div');
            item.className = 'sidebar-illustration-item';
            
            // Check if we have a video URL (skip if already shown in sermon clips)
            let videoHtml = '';
            let illVideoId = null;
            if (url && url.includes('youtube.com')) {
                const videoIdMatch = url.match(/v=([a-zA-Z0-9_-]+)/);
                if (videoIdMatch) {
                    illVideoId = videoIdMatch[1];
                    // Skip if this video is already shown in sermon clips
                    if (globalVideoIds.has(illVideoId)) {
                        console.log('Skipping illustration - video already in sermon clips:', illVideoId);
                        return;
                    }
                    let startSeconds = 0;
                    const timeMatch = url.match(/[&?]t=(\d+)/);
                    if (timeMatch) startSeconds = parseInt(timeMatch[1]);
                    const embedUrl = `https://www.youtube-nocookie.com/embed/${illVideoId}?start=${startSeconds}&rel=0&modestbranding=1&playsinline=1&enablejsapi=1`;
                    videoHtml = `<iframe src="${embedUrl}" title="${title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen playsinline webkit-playsinline loading="lazy"></iframe>`;
                    // Mark this video as used
                    globalVideoIds.add(illVideoId);
                }
            }
            
            item.innerHTML = `
                ${videoHtml}
                <div class="sidebar-illustration-info">
                    <div class="illustration-title">${title || 'Illustration'}</div>
                    <div class="illustration-text">${text || ''}</div>
                    <span class="illustration-tone">${tone || 'inspiring'}</span>
                    ${timestamp ? `<span class="illustration-timestamp">${timestamp}</span>` : ''}
                </div>
            `;
            
            // Add to beginning of list
            illustrationList.insertBefore(item, illustrationList.firstChild);
            
            illustrationCount++;
            illustrationCountEl.textContent = illustrationCount;
            
            console.log('Added illustration:', title);
        }
        
        function clearIllustrationSidebar() {
            const illustrationList = document.getElementById('illustrationList');
            const illustrationCountEl = document.getElementById('illustrationCount');
            const emptyState = document.getElementById('illustrationEmptyState');
            
            const items = illustrationList.querySelectorAll('.sidebar-illustration-item');
            items.forEach(item => item.remove());
            
            if (emptyState) {
                emptyState.style.display = 'block';
            }
            
            illustrationCount = 0;
            addedIllustrationKeys.clear();
            illustrationCountEl.textContent = '0';
        }
        
        function clearAllVideoDedup() {
            globalVideoIds.clear();
        }
        
        function formatSecondsToTimestamp(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function formatMessageText(text) {
            // Remove any YouTube URLs Grok might have hallucinated (we get real ones from server)
            let result = text.replace(/https?:\/\/(?:www\.)?youtube\.com\/watch\?[^\s\])<>]*/gi, '');
            
            // Clean up extra whitespace and line breaks
            result = result.replace(/\n\s*\n\s*\n/g, '\n\n');
            result = result.replace(/^\s+|\s+$/g, '');
            
            // Escape HTML
            result = result.replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;');
            
            // Format scripture references
            result = result.replace(
                /([1-3]?\s?[A-Z][a-z]+)\s+(\d+):(\d+(?:-\d+)?)/g,
                '<span class="scripture-ref">$1 $2:$3</span>'
            );
            
            // Convert line breaks
            result = result.replace(/\n/g, '<br>');
            
            return result;
        }
        
        function formatMessageWithLinks(text) {
            // Legacy function - just use formatMessageText now
            return formatMessageText(text);
        }
        
        function formatSecondsToTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        function showTyping() {
            const chatMessages = document.getElementById('chatMessages');
            const existingTyping = chatMessages.querySelector('.typing');
            
            if (!existingTyping) {
                const typing = document.createElement('div');
                typing.className = 'typing';
                typing.innerHTML = '<span></span><span></span><span></span>';
                chatMessages.appendChild(typing);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Clear any existing timeout
            if (typingTimeout) clearTimeout(typingTimeout);
            
            // Remove typing after 5 seconds if no response
            typingTimeout = setTimeout(() => {
                const typing = chatMessages.querySelector('.typing');
                if (typing) typing.remove();
            }, 5000);
        }

        function hideTyping() {
            const typing = document.getElementById('chatMessages').querySelector('.typing');
            if (typing) typing.remove();
            if (typingTimeout) clearTimeout(typingTimeout);
        }

        // ============================================
        // TEXT INPUT FUNCTIONS
        // ============================================
        async function handleTextInputFocus() {
            // Don't auto-connect on focus - only connect when actually needed for voice response
            // This avoids the greeting problem entirely
            log('Text input focused - voice will connect if needed for response', 'info');
        }
        
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendTextMessage();
            }
        }

        async function sendTextMessage() {
            const input = document.getElementById('textInput');
            const sendBtn = document.getElementById('sendBtn');
            const text = input.value.trim();
            
            if (!text) return;
            
            // Add user message to chat and history
            addMessage(text, 'user');
            conversationHistory.push({ role: 'user', content: text });
            
            // Clear input and disable while sending
            input.value = '';
            input.disabled = true;
            sendBtn.disabled = true;
            
            // Show typing indicator
            showTyping();
            
            try {
                log('Sending text message to Grok API: ' + text, 'info');
                
                // Call the Grok API
                const response = await fetch(GROK_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        messages: conversationHistory,
                        model: 'grok-3',  // Using latest available model
                        temperature: 0.7,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';
                let currentMessage = null;

                hideTyping();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const parsed = JSON.parse(data);
                                
                                // Handle sermon_videos event from server (real URLs from ChromaDB)
                                if (parsed.sermon_videos) {
                                    console.log('ðŸ“º Received sermon videos from server:', parsed.sermon_videos.length);
                                    parsed.sermon_videos.forEach(video => {
                                        addVideoToSidebar(video.title, video.url, video.timestamp, video.text);
                                    });
                                    continue;
                                }
                                
                                // Handle illustrations event from server
                                if (parsed.illustrations) {
                                    console.log('ðŸ’¡ Received illustrations from server:', parsed.illustrations.length);
                                    parsed.illustrations.forEach(ill => {
                                        addIllustrationToSidebar(ill.title, ill.text, ill.tone, ill.url, ill.timestamp);
                                    });
                                    continue;
                                }
                                
                                if (parsed.choices?.[0]?.delta?.content) {
                                    const content = parsed.choices[0].delta.content;
                                    fullResponse += content;
                                    
                                    // Create or update the message in the chat
                                    if (!currentMessage) {
                                        currentMessage = document.createElement('div');
                                        currentMessage.className = 'message agent';
                                        document.getElementById('chatMessages').appendChild(currentMessage);
                                        document.getElementById('chatMessages').scrollTop = 
                                            document.getElementById('chatMessages').scrollHeight;
                                    }
                                    // Use innerHTML to format (but don't extract URLs - server sends real ones)
                                    currentMessage.innerHTML = formatMessageText(fullResponse);
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }

                // Add to conversation history
                if (fullResponse) {
                    conversationHistory.push({ role: 'assistant', content: fullResponse });
                    log('Received response from Grok', 'success');
                    
                    // If voice response is enabled, connect if needed and speak
                    if (voiceResponseEnabled) {
                        if (!isConnected) {
                            // Store the text to be spoken before connecting
                            window.pendingTextToSpeak = fullResponse;
                            
                            // Connect silently just for speaking this response
                            log('Connecting voice to speak response...', 'info');
                            await connect(false); // false = no greeting
                            // The connect function will handle sending the text to the agent
                            // No need to wait here as the agent will speak automatically
                        }
                        
                        if (isConnected && room && room.localParticipant) {
                            // Voice agent should now be speaking the response
                            log('Voice agent speaking the response', 'info');
                            
                            // Don't auto-disconnect here - let the agent finish speaking
                            // The disconnect will happen from the data message handler
                        }
                    } else {
                        log('Voice response disabled - text only', 'info');
                    }
                }

            } catch (error) {
                log('Error sending message: ' + error.message, 'error');
                hideTyping();
                addMessage('Failed to send message. Please try again.', 'system');
            } finally {
                // Re-enable input
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        // ============================================
        // CONTEXT SYNCHRONIZATION
        // ============================================
        function getConversationContext() {
            // Get recent conversation for context (excluding system messages)
            return conversationHistory
                .filter(msg => msg.role !== 'system')
                .slice(-20); // Last 20 messages for context
        }

        // Function to have the voice agent speak text responses
        async function speakTextResponse(text) {
            if (!room || !room.localParticipant) {
                log('Cannot speak - not connected to voice room', 'warning');
                return;
            }
            
            try {
                // For now, we'll use the agent's generate_reply capability
                // The agent should speak the text we send
                log('Voice agent will speak the response', 'info');
                
                // Don't disconnect based on estimated duration
                // Let the agent complete speaking naturally
                
            } catch (error) {
                log('Error with voice agent: ' + error.message, 'error');
            }
        }

        function clearConversation() {
            conversationHistory = [
                {
                    role: 'system',
                    content: conversationHistory[0].content
                }
            ];
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '<div class="message system">Conversation cleared. Start fresh with voice or text!</div>';
            
            // Also clear the video sidebar and illustration sidebar
            clearVideoSidebar();
            clearIllustrationSidebar();
        }

        // ============================================
        // LOGGING
        // ============================================
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = {
                'error': 'âŒ',
                'success': 'âœ…',
                'warning': 'âš ï¸',
                'info': 'â†’'
            }[type] || 'â†’';
            
            console.log(`[${timestamp}] ${prefix} ${message}`);
            
            const panel = document.getElementById('debugPanel');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${prefix} ${message}`;
            panel.appendChild(entry);
            panel.scrollTop = panel.scrollHeight;
        }

        // ============================================
        // MAIN TOGGLE
        // ============================================
        async function toggleVoice() {
            if (isConnected) {
                disconnect();
            } else {
                await connect(true); // true = show greeting
            }
        }

        // ============================================
        // CONNECT
        // ============================================
        async function connect(showGreeting = true) {
            const btn = document.getElementById('voiceBtn');
            const status = document.getElementById('voiceStatus');
            
            // Store whether this is a silent connection
            silentConnection = !showGreeting;
            
            btn.classList.add('connecting');
            btn.disabled = true;
            status.textContent = 'Connecting...';
            
            log('Starting connection...', 'info');
            addMessage('Connecting to voice assistant...', 'system');

            try {
                // Step 1: Check microphone
                log('Requesting microphone access...', 'info');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                log('Microphone access granted', 'success');
                stream.getTracks().forEach(t => t.stop()); // Release for now

                // Step 2: Get token with unique room name and context
                log('Fetching token from server...', 'info');
                // Use the fixed room name that the agent is listening to
                const roomName = 'apb-voice-room';
                
                // Pass conversation context to voice agent
                const contextMessages = getConversationContext();
                
                const response = await fetch(TOKEN_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        roomName,
                        context: contextMessages // Pass conversation context to voice agent
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const data = await response.json();
                log(`Token received for room: ${data.roomName || roomName}`, 'success');
                log(`LiveKit URL: ${data.url}`, 'info');
                
                // Validate URL
                if (!data.url?.startsWith('wss://')) {
                    log('WARNING: URL should be wss://', 'warning');
                }

                // Step 3: Create room
                log('Creating LiveKit room...', 'info');
                room = new LivekitClient.Room({
                    adaptiveStream: true,
                    dynacast: true,
                    audioCaptureDefaults: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                    }
                });

                // Step 4: Set up event handlers
                setupEventHandlers();

                // Step 5: Connect with transcription enabled
                log('Connecting to LiveKit with transcription...', 'info');
                const roomOptions = {
                    publishDefaults: {
                        dtx: true,
                        red: true,
                    },
                    adaptiveStream: true,
                    dynacast: true,
                };
                await room.connect(data.url, data.token, roomOptions);
                log(`Connected to room: ${room.name}`, 'success');

                // Step 6: Enable microphone - CRITICAL!
                log('Enabling microphone...', 'info');
                await room.localParticipant.setMicrophoneEnabled(true);
                log('Microphone enabled and publishing audio', 'success');
                
                // Enable transcriptions to see what's being said
                await room.localParticipant.setTrackSubscriptionPermissions({
                    allParticipantTracks: true,
                    allTracks: true
                });

                // Verify
                const tracks = room.localParticipant.audioTrackPublications;
                log(`Audio tracks published: ${tracks.size}`, 'info');
                
                // Send connection type to agent and store response text if available
                if (!showGreeting) {
                    // Send silent connection signal IMMEDIATELY to beat the greeting timeout
                    // The agent only waits 500ms, so we need to send this right away
                    (async () => {
                        try {
                            // Store the text to be spoken
                            const textToSpeak = window.pendingTextToSpeak || null;
                            
                            if (textToSpeak) {
                                log('Sending text to voice agent: ' + textToSpeak.substring(0, 50) + '...', 'info');
                            }
                            
                            const encoder = new TextEncoder();
                            const data = encoder.encode(JSON.stringify({
                                type: 'silent_connection',
                                textToSpeak: textToSpeak
                            }));
                            await room.localParticipant.publishData(data, { reliable: true });
                            log('Sent silent connection signal to agent immediately', 'info');
                            
                            // Don't set a disconnect timer here
                            // The agent will send a 'speech_complete' signal when done
                            // and we'll disconnect then
                            if (textToSpeak) {
                                log('Waiting for agent to finish speaking...', 'info');
                            }
                            
                            // Clear the pending text
                            window.pendingTextToSpeak = null;
                        } catch (err) {
                            log('Could not send connection type: ' + err.message, 'warning');
                        }
                    })(); // Execute immediately, no setTimeout
                }

                // Step 7: Start monitoring
                startAudioMonitoring();
                
                // Wait a moment then check for agent
                setTimeout(() => {
                    checkForAgent();
                    // Only show greeting for microphone button connections
                    if (showGreeting) {
                        setTimeout(() => {
                            if (room.remoteParticipants.size > 0) {
                                log('Agent connected, expecting greeting...', 'info');
                            }
                        }, 1000);
                    } else {
                        log('Silent connection for text input - no greeting', 'info');
                    }
                }, 500);

                // Update UI
                isConnected = true;
                
                // Always update button to show stop icon when connected
                btn.classList.remove('connecting');
                btn.classList.add('listening');
                btn.disabled = false;
                document.getElementById('micIcon').style.display = 'none';
                document.getElementById('stopIcon').style.display = 'block';
                
                if (showGreeting) {
                    // Full UI update for microphone connections
                    status.textContent = 'Connected â€” Speak now!';
                    log('Voice connection ready!', 'success');
                    log('Speak or continue typing messages', 'info');
                    addMessage('Voice connected! Speak now or continue typing.', 'system');
                } else {
                    // UI update for text-to-speech connections
                    status.textContent = 'Speaking response...';
                    log('Voice connected for text response', 'info');
                }

            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                console.error('Full error:', error);
                
                btn.classList.remove('connecting');
                btn.disabled = false;
                status.textContent = 'Connection failed. Tap to retry.';
                addMessage('Connection failed. Please try again.', 'system');
                
                if (room) {
                    room.disconnect();
                    room = null;
                }
            }
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        function setupEventHandlers() {
            // Participant joined
            room.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
                log(`Participant joined: ${participant.identity}`, 'success');
                updateAgentStatus(true);
            });

            // Participant left
            room.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
                log(`Participant left: ${participant.identity}`, 'info');
                updateAgentStatus(false);
            });

            // Track subscribed - when we receive audio from agent
            room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                log(`Received ${track.kind} from ${participant.identity}`, 'success');
                
                if (track.kind === 'audio') {
                    const audio = document.getElementById('agentAudio');
                    track.attach(audio);
                    audio.play().then(() => {
                        log('Agent audio playing!', 'success');
                        updateAgentStatus(true, true);
                    }).catch(e => {
                        log(`Audio play blocked: ${e.message}`, 'warning');
                        log('Click anywhere to enable audio', 'info');
                    });
                }
            });

            // Track unsubscribed
            room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
                log(`Track unsubscribed: ${track.kind}`, 'info');
                track.detach();
                updateAgentStatus(true, false);
            });

            // Our track published
            room.on(LivekitClient.RoomEvent.LocalTrackPublished, (pub) => {
                log(`Your ${pub.kind} track published`, 'success');
            });

            // Transcription events - only log, don't display (use DataReceived instead to avoid duplicates)
            room.on(LivekitClient.RoomEvent.TranscriptionReceived, (segments, participant) => {
                const text = segments.map(s => s.text).join(' ').trim();
                if (!text) return;
                // Just log for debugging - actual display handled by DataReceived events
                log(`Transcription (${participant.identity}): "${text.substring(0, 50)}..."`, 'info');
            });

            // Track last messages to avoid duplicates
            let lastAgentMessage = '';
            let lastUserMessage = '';
            
            // Data received event for context sync
            room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant, kind, topic) => {
                try {
                    const raw = payload instanceof Uint8Array ? payload : (payload.payload || payload.data || payload);
                    const decoder = new TextDecoder();
                    const decoded = decoder.decode(raw);
                    console.log('RAW DATA RECEIVED:', decoded.substring(0, 200));
                    const message = JSON.parse(decoded);
                    log(`Data message: ${message.type}`, 'info');
                    
                    if (message.type === 'context_update') {
                        log('Received context update from agent', 'info');
                    } else if (message.type === 'user_transcript') {
                        // Display user's spoken text in chat (with deduplication)
                        if (message.text && message.text !== lastUserMessage) {
                            lastUserMessage = message.text;
                            addMessage(message.text, 'user');
                            conversationHistory.push({ role: 'user', content: message.text });
                            setTimeout(showTyping, 500);
                            if (autoDisconnectTimer) {
                                clearTimeout(autoDisconnectTimer);
                                autoDisconnectTimer = null;
                                log('Auto-disconnect cancelled - user speaking', 'info');
                            }
                        }
                    } else if (message.type === 'agent_transcript') {
                        // Display agent's spoken text in chat (with deduplication)
                        if (message.text && message.text !== lastAgentMessage) {
                            lastAgentMessage = message.text;
                            hideTyping();
                            addMessage(message.text, 'agent');
                            conversationHistory.push({ role: 'assistant', content: message.text });
                            if (autoDisconnectTimer) {
                                clearTimeout(autoDisconnectTimer);
                            }
                            autoDisconnectTimer = setTimeout(() => {
                                if (isConnected) {
                                    log('Auto-disconnecting after inactivity', 'info');
                                    addMessage('Voice session ended due to inactivity', 'system');
                                    disconnect();
                                }
                            }, AUTO_DISCONNECT_DELAY);
                        }
                    } else if (message.type === 'sermon_reference') {
                        log('Received sermon reference', 'info');
                        if (message.url) {
                            addVideoToSidebar(message.title, message.url, message.timestamp, message.text);
                        }
                    } else if (message.type === 'illustration') {
                        log('Received illustration from voice agent', 'info');
                        addIllustrationToSidebar(
                            message.title || 'Illustration',
                            message.text || '',
                            message.tone || '',
                            message.url || '',
                            ''
                        );
                    } else if (message.type === 'speech_complete') {
                        // Agent finished speaking
                        log('Agent finished speaking', 'info');
                        
                        // Auto-disconnect after a short delay if this was a silent connection
                        if (silentConnection) {
                            setTimeout(() => {
                                if (isConnected && silentConnection) {
                                    log('Auto-disconnecting after speech complete', 'info');
                                    disconnect();
                                }
                            }, 2000); // 2 second delay after speech completes
                        }
                    }
                } catch (error) {
                    console.error('Error parsing data message:', error);
                }
            });

            // Disconnection
            room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
                log(`Disconnected: ${reason || 'unknown'}`, 'warning');
                addMessage('Disconnected from voice assistant', 'system');
                disconnect();
            });

            // Errors
            room.on(LivekitClient.RoomEvent.MediaDevicesError, (error) => {
                log(`Media error: ${error.message}`, 'error');
            });
        }

        // ============================================
        // HELPERS
        // ============================================
        function checkForAgent() {
            const participants = room.remoteParticipants;
            log(`Checking for agent (${participants.size} remote participants)`, 'info');
            
            participants.forEach((p, id) => {
                log(`  Found: ${id}`, 'info');
                updateAgentStatus(true);
                
                // Subscribe to existing tracks
                p.trackPublications.forEach(pub => {
                    if (pub.track && pub.kind === 'audio') {
                        const audio = document.getElementById('agentAudio');
                        pub.track.attach(audio);
                        audio.play().catch(() => {});
                    }
                });
            });
        }

        function updateAgentStatus(connected, speaking = false) {
            const el = document.getElementById('agentStatus');
            if (connected) {
                el.classList.add('active');
                if (speaking) {
                    el.classList.add('speaking');
                    el.textContent = 'ðŸ”Š Agent Speaking';
                } else {
                    el.classList.remove('speaking');
                    el.textContent = 'ðŸ¤– Agent Connected';
                }
            } else {
                el.classList.remove('active', 'speaking');
            }
        }

        function startAudioMonitoring() {
            const tracks = room.localParticipant.audioTrackPublications;
            
            tracks.forEach(pub => {
                if (pub.track?.mediaStreamTrack) {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = new MediaStream([pub.track.mediaStreamTrack]);
                    const source = ctx.createMediaStreamSource(stream);
                    const analyser = ctx.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    
                    const data = new Uint8Array(analyser.frequencyBinCount);
                    
                    audioMonitorInterval = setInterval(() => {
                        if (!isConnected) {
                            clearInterval(audioMonitorInterval);
                            ctx.close();
                            return;
                        }
                        
                        analyser.getByteFrequencyData(data);
                        const avg = data.reduce((a, b) => a + b, 0) / data.length;
                        const level = Math.min(100, avg * 1.5);
                        
                        document.getElementById('audioLevelFill').style.width = `${level}%`;
                        document.getElementById('audioLevelValue').textContent = Math.round(avg);
                    }, 100);
                }
            });
        }

        // ============================================
        // DISCONNECT
        // ============================================
        function disconnect() {
            log('Disconnecting...', 'info');
            
            // Clear auto-disconnect timer
            if (autoDisconnectTimer) {
                clearTimeout(autoDisconnectTimer);
                autoDisconnectTimer = null;
            }
            
            // Add message to chat if this was a user-initiated stop
            if (isConnected) {
                addMessage('Voice assistant stopped', 'system');
            }
            
            if (audioMonitorInterval) {
                clearInterval(audioMonitorInterval);
                audioMonitorInterval = null;
            }
            
            if (room) {
                room.disconnect();
                room = null;
            }
            
            isConnected = false;
            
            const btn = document.getElementById('voiceBtn');
            btn.classList.remove('listening', 'connecting');
            btn.disabled = false;
            document.getElementById('micIcon').style.display = 'block';
            document.getElementById('stopIcon').style.display = 'none';
            
            document.getElementById('voiceStatus').textContent = 'Tap to connect';
            document.getElementById('audioLevelFill').style.width = '0%';
            document.getElementById('audioLevelValue').textContent = '0';
            updateAgentStatus(false);
            hideTyping();
            
            log('Disconnected', 'info');
            addMessage('Conversation ended', 'system');
        }

        // ============================================
        // PAGE EVENTS
        // ============================================
        window.addEventListener('beforeunload', () => {
            if (room) room.disconnect();
        });

        // Enable audio on click (for autoplay policy)
        document.addEventListener('click', () => {
            const audio = document.getElementById('agentAudio');
            if (audio.paused && audio.srcObject) {
                audio.play().catch(() => {});
            }
        });

        // Fix viewport height on mobile
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setViewportHeight();
        window.addEventListener('resize', setViewportHeight);
        window.addEventListener('orientationchange', setViewportHeight);

        // Prevent zoom on input focus (iOS)
        document.addEventListener('touchstart', (e) => {
            if (e.target.nodeName === 'INPUT' || e.target.nodeName === 'TEXTAREA') {
                e.target.style.fontSize = '16px';
            }
        });

        // Initialize voice response toggle on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Set up voice response toggle
            const voiceToggle = document.getElementById('voiceResponseCheckbox');
            if (voiceToggle) {
                // Load saved preference
                const savedPreference = localStorage.getItem('voiceResponseEnabled');
                if (savedPreference !== null) {
                    voiceResponseEnabled = savedPreference === 'true';
                    voiceToggle.checked = voiceResponseEnabled;
                    // Update initial label
                    const label = document.querySelector('.toggle-label');
                    if (label) {
                        label.textContent = voiceResponseEnabled ? 'VOICE' : 'TEXT';
                    }
                }
                
                // Handle toggle changes
                voiceToggle.addEventListener('change', (e) => {
                    voiceResponseEnabled = e.target.checked;
                    localStorage.setItem('voiceResponseEnabled', voiceResponseEnabled);
                    
                    const status = voiceResponseEnabled ? 'enabled' : 'disabled';
                    log(`Voice response ${status} for typed messages`, 'info');
                    
                    // Update toggle label
                    const label = document.querySelector('.toggle-label');
                    if (label) {
                        label.textContent = voiceResponseEnabled ? 'VOICE' : 'TEXT';
                    }
                });
            }
        });

        // Startup
        log('APB Voice & Chat ready', 'success');
        log('Type a message or click the microphone', 'info');
        // Test function - call testVideoEmbed() from browser console to verify embedding works
        window.testVideoEmbed = function() {
            const testMsg = `Here's a test video from Pastor Bob:

https://www.youtube.com/watch?v=L2KBxtxYBiw&t=5307s

This should show an embedded video above.`;
            console.log('Testing video embed with message:', testMsg);
            addMessage(testMsg, 'agent');
        };

        // Debug function to test the regex
        window.testRegex = function(url) {
            const urlPattern = /https?:\/\/(?:www\.)?youtube\.com\/watch\?[^\s]*v=([a-zA-Z0-9_-]+)(?:[^\s]*&t=(\d+)s?)?/gi;
            const match = urlPattern.exec(url || 'https://www.youtube.com/watch?v=L2KBxtxYBiw&t=5307s');
            if (match) {
                console.log('âœ… Match found!');
                console.log('  Full match:', match[0]);
                console.log('  Video ID:', match[1]);
                console.log('  Seconds:', match[2]);
            } else {
                console.log('âŒ No match for URL:', url);
            }
        };

        console.log('ðŸ’¡ Debug: Run testVideoEmbed() in console to test video embedding');
        console.log('ðŸ’¡ Debug: Run testRegex("your-url") to test if a URL matches the pattern');
    </script>
</body>
</html>